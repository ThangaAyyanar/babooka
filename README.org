#+title: Babashka Babooka

* Introduction

There are two types of programmers in the world: the practical, sensible,
shell-resigned people who need to google the correct argument order for ~ln -s~,
and those twisted, Stochholmed souls who will gleefully spend a weekend cooking
up hundreds of lines of bash.

This guide is for the former. For the latter: sorry, but I can't help you.

[[https://babashka.org][Babashka]] is a Clojure scripting runtime that is a powerful, delightful
alternative to the shell scripts you're used to; this comprehensive tutorial
will will help you understand:

- What babashka is, what it does, how it works, and how it can fit into your
  toolset
- How to write babashka scripts
- How to organize your babashka projects
- What pods and tasks are, and how to use them

If you'd like to stop doing something that hurts (writing incomprehensible shell
scripts) and start doing something that feels great (writing Babashka scripts),
then read on!

** What is Babashka?

From a user perspective, babashka is a scripting runtime for the Clojure
programming language. It lets you execute Clojure programs in contexts where
you'd typically use bash, ruby, python, and the like. Use cases include build
scripts, command line utilities, small web applications, git hooks, AWS Lambda
functions, and everywhere you want to use Clojure where fast startup and/or low
resource usage matters.

You can run something like the following in a terminal to immediately execute
your Clojure program:

#+begin_src bash
bb my-clojure-program.clj
#+end_src

If you're familiar with Clojure, you'll find this significant because it
eliminates the startup time you'd otherwise have to contend with for a
JVM-compiled Clojure program. It also uses much less memory than running a jar.
Babashka makes it feasible to use Clojure even more than you already do.

If you're unfamiliar with Clojure, using Babashka is a great way to try out the
language. Clojure is a /hosted/ language, meaning that the language is defined
independently of the underlying runtime environment. Most Clojure programs are
compiled to run on the Java Virtual Machine so that they can be run anywhere
Java runs. The other main target is JavaScript, allowing Clojure to run in a
browser. With Babashka, you can now run Clojure programs where you'd normally
run bash scripts. The time you spend investing in Clojure pays dividends as your
knowledge transfers to these varied environments. (Note that this tutorial
assumes basic familiarity with Clojure.)

From an implementation perspective, Babashka is a standalone, natively-compiled
binary, meaning that it executes "directly" on the operating system, rather than
runningin a JVM. When the babashka binary gets compiled, it includes many
Clojure namespaces and libraries so that they are usable with native
performance. You can [[https://book.babashka.org/#libraries][check out the full list of built-in namespaces]]. Babashka
can also include other libraries, just like if you're using deps.edn or
Leiningen.

The binary also includes the [[https://github.com/babashka/SCI][Small Clojure Interpreter (SCI)]] to interpret the
Clojure you write and additional libraries you include on the fly. Its
implementation of Clojure is nearly at parity with JVM Clojure, and it improves
daily thanks to [[https://github.com/borkdude][Michiel Borkent]]'s ceaseless work. It's built with GraalVM. This
guide is focused on becoming productive with Babashka and doesn't cover the
implementation in depth.

** Why should you use it?

I won't go into the benefits of Clojure itself because there are plenty of
materials on that [[https://jobs-blog.braveclojure.com/2022/03/24/long-term-clojure-benefits.html][elsewhere]].

Beyond the fact that it's Clojure, Babashka brings a few features that make it
stand apart from contenders:

*First-class support for multi-threaded programming.* Clojure makes
multi-threaded programming simple and easy to write and reason about. With
Babashka, you can write straightforward scripts that e.g. fetch data from
multiple databases in parallel.

*Real testing.* You can unit test your Babashka code just as you would any other
Clojure project, and you can use other testing libraries as you see fit.

*Interactive Development.* Following the lisp tradition, Babashka provides a
read-eval-print loop (REPL) that gives you that good good bottom-up
fast-feedback feeling. Script development is inherently a fast; Babashka makes
it faster.

*Built-in tools for defining your script's interface.* One reason to write a
shell script is to provide a concise, understandable interface for a complicated
process. For example, you might write a build script that includes ~build~ and
~deploy~ commands that you call like

#+begin_src bash
./my-script build
./my-script deploy
#+end_src

Babashka comes with a task interface which gives you a consistent way of
defining such commands, and for parsing command-line arguments into Clojure data
structures. Take that, bash!

*A rich set of libraries.* Babashka comes with helper utilities for doing
typical shell script grunt work like interacting with processes or mucking about
with the filesystem. It also has support for the following without needing extra
dependencies:

- JSON parsing
- YAML parsing
- Starting an HTTP server
- Writing generative tests

And of course, you can add Clojure libraries as dependencies to accomplish even
more. Clojure is a gateway drug to other programming paradigms, so if you ever
wanted to do e.g. logic programming from the command line, now's your chance!

*Good error messages.* TODO

** Installation

Installing with brew is ~brew install borkdude/brew/babashka~.

[[https://github.com/babashka/babashka#installation][For other systems, see Babashka's complete installation instructions.]]

* Your first script

Throughout this tutorial we're going to play with building a little CLI-based
dream journal. Why? Because the idea of you nerds recording your weird little
subconscious hallucinations is deeply amusing to me.

In this section, you're going to learn:

- How to write and run your first Babashka script
- How default output is handled
- A little about how Babashka treats namespaces

Create a file named ~hello.clj~ and put this in it:

#+begin_src clojure
(require '[clojure.string :as str])
(str/join " " ["Hello" "inner" "world!"])
#+end_src

Now run it with ~bb~, the babashka executable:

#+begin_src clojure
bb hello.clj
#+end_src

You should see it print the text ~"Hello inner world!"~.

There are a few things here to point out for experienced Clojurians:

- You didn't need a deps.edn file or project.clj
- There's no namespace declaration; we use ~(require ...)~
- You didn't need to print the string for the string to be printed
- It's just Clojure

I very much recommend that you actually try this example before proceeding
because it /feels/ different from what you're used to. It's unlikely that you're
used to throwing a few Clojure expressions into a file and being able to run
them immediately.

When I first started using Babashka, it felt so different that it was
disorienting. It was like the first time I tried driving an electric car and my
body freaked out a little because I wasn't getting the typical sensory cues like
hearing and feeling the engine starting.

Babashka's like that: the experience is so quiet and smooth it's jarring. No
deps.edn, no namespace declaration, write only the code you need and it runs!

That's why I included the "It's just Clojure" bullet point. It might feel
different, but this is still Clojure. Let's explore the other points in more
detail.

** Babashka's output

Here's what's going on: ~bb~ interprets the Clojure code you've written,
executing it on the fly. It prints the last value it encounters to ~stdout~,
which is why ~"Hello, inner world!"~ is returned in your terminal.

Notice that the quotes are maintained when the value is printed. ~bb~ will
print the /stringified representation of your data structure/. If you updated
~hello.clj~ to read

#+begin_src clojure
"Hello, inner world!"
["It's" "me," "your" "wacky" "subconscious!"]
#+end_src

Then ~["It's" "me," "your" "wacky" "subconscious!"]~ would get printed, and
~"Hello, inner world!"~ would not.

If you want to print a string without the surrounding quotes, you can use

#+begin_src clojure
(println "Hello, inner world!")
nil
#+end_src

With ~nil~ as the last form, ~bb~ does not print to ~stdout~ on exit.

** Namespace is optional

As for the lack of namespace: this is part of what makes Babashka useful as a
scripting tool. When you're in a scripting state of mind, you want to start
hacking on ideas immediately; you don't want to have to deal with boilerplate
just to get started. Babashka has your back.

You /can/ define a namespace (we'll look at that more when we get into project
organization), but if you don't then Babashka uses the ~user~ namespace by
default. Try updating your file to read:

#+BEGIN_SRC clojure
(str "Hello from " *ns* ", inner world!")
#+END_SRC

Running it will print ~"Hello from user, inner world!"~. This might be
surprising becase there's a mismatch between filename (~hello.clj~) and
namespace name. In other Clojure implementations, the current namespace strictly
corresponds to the source file's filename, but Babashka relaxes that a little
bit in this specific context. It provides a scripting experience that's more in
line with what you'd expect from using other scripting languages.

** What about requiring other namespaces?

You might want to include a namespace declaration because you want to require
other namespaces. With JVM Clojure and Clojurescript, you require other
namespaces like this:

#+begin_src clojure
(ns user
  (:require
   [clojure.string :as str]))
#+end_src

It's considered bad form to require namespaces by putting ~(require
'[clojure.string :as str])~ in your source code.

That's not the case with Babashka. You'll see ~(require ...)~ used liberally in
other examples, and it's OK for you to do that too.

** Executable script

What if you want to execute your script by typing something like ~./hello~
instead of ~bb hello.clj~? You just need to rename your file, add a shebang, and
~chmod +x~ that bad boy. Update ~hello.clj~ to read:

#+begin_src clojure
#!/usr/bin/env bb

(str "Hello from " *ns* ", inner world!")
#+end_src

Then run this in your terminal:

#+begin_src bash
mv hello{.clj,}
chmod +x hello
./hello
#+end_src

** Summary

Here's what you learned in this section:

- You can run scripts with ~bb script-name.clj~
- You can make scripts directly executable by adding ~#!/usr/bin/env bb~ on the
  top line and adding the ~execute~ permission with ~chmod +x script-name.clj~
- You don't have to include an ~(ns ...)~ declaration in your script. But it
  still runs and it's still Clojure!
- It's acceptable and even encouraged to require namespaces with ~(require
  ...)~.
- Babashka writes the last value it encounters to ~stdout~

* Working with files

Shell scripts often need to read input from the command line and produce output
somewhere, and our dream journal utility is no exception. It's going to store
entries in the file ~entries.edn~. The journal will be a vector, and each entry
will be a map with the keys ~:timestamp~ and ~:entry~ (the entry has linebreaks
for readability):

#+BEGIN_SRC clojure
[{:timestamp 0
  :entry     "Dreamt the drain was clogged again, except when I went to unclog
              it it kept growing and getting more clogged and eventually it
              swallowed up my little unclogger thing"}
 {:timestamp 1
  :entry     "Was giving a tour of the house I just bought, moved to the backyard
              and all the... topiary? came alive and I had to fight it with a sword.
              I understood that this happens every night was very annoyed that this
              was not disclosed in the listing."}]
#+END_SRC

To write to the journal, we want to run the command ~./journal add --entry
"Hamsters. Hamsters everywhere. Again."~. The result should be that a map gets
appended to the vector.

Let's get ourselves part of the way there. Create the file ~journal~ and make it
executable with ~chmod +x journal~, then make it look like this:

#+begin_src clojure
#!/usr/bin/env bb

(require '[babashka.fs :as fs])
(require '[clojure.edn :as edn])

(def ENTRIES-LOCATION "entries.edn")

(defn read-entries
  []
  (if (fs/exists? ENTRIES-LOCATION)
    (edn/read-string (slurp ENTRIES-LOCATION))
    []))

(defn add-entry
  [text]
  (let [entries (read-entries)]
    (spit ENTRIES-LOCATION
          (conj entries {:timestamp (System/currentTimeMillis)
                         :entry     text}))))

(add-entry (first *command-line-args*))
#+end_src

We require a couple namespaces: ~babashka.fs~ and ~clojure.edn~. ~babashka.fs~ is
a collection of functions for working with the filesystem; check out its [[https://github.com/babashka/fs][API
docs]]. When you're writing shell scripts, you're very likely to work with the
filesystem, so this namespace is going to be your friend.

In this case, the ~read-entries~ function is using ~fs/exists?~ to check that
~entries.edn~ exists before attempting to read it because ~slurp~ will throw an
exception if it can't find the file for the path you passed it.

The ~add-entry~ function gets the entries as a Clojure data structure, ~conj~s
an entry, and then uses ~spit~ to write to ~entries.edn~. By default, ~spit~
will overwrite a file; if you want to append to it, you would call it like

#+begin_src clojure
(spit "entries.edn" {:timestap 0 :entry ""} :append true)
#+end_src

* Creating an interface for your script

In the last line we call ~(add-entry (first *command-line-args*))~.
~*command-line-args*~ is a sequence containing, well, all the command line
arguments that were passed to the script. If you were to create the file
~args.clj~ with the contents ~*command-line-args*~, then ran ~bb args.clj 1 2
3~, it would print ~("1" "2" "3")~.

With this code we can add an entry by calling ~./journal "Flying!! But to IHOP??"~.
This is almost what we want; we actually want to call ~./journal add --entry "entry text"~.
The assumption here is that we'll want to have other commands like ~./journal
list~ or ~./joural delete~.

To accomplish this, we'll need to handle the commind line arguments in a more
sophisticated way. The most obvious and least-effort way to do this would be to
dispatch on the first argument to ~*command-line-args*~, something like this:

#+BEGIN_SRC clojure
(let [[command _ entry] *command-line-args*]
  (case command
    "add" (add-entry entry)))
#+END_SRC

This might be totally fine for your use case, but sometimes you want something
more robust. You might want your script to:

- List valid commands
- Give an intelligent error message when a user calls a command that doesn't
  exist (e.g. if the user calls ~./journal add-dream~ instead of ~./journal
  add~)
- Parse arguments, recognizing option flags and converting values to keywords,
  numbers, vectors, maps, etc

Generally speaking, *you want a clear and consistent way to define an interface
for your script*. This interface is responsible for taking the data provided at
the command line -- arguments passed to the script, as well as data piped in
through ~stdin~ -- and using that data to handle these three responsibilities:

- Dispatching to a Clojure function
- Parsing command-line arguments into Clojure data, and passing that to the
  dispatched functon
- Providing feedback in cases where there's a problem performing the above
  responsibilities.

The broader Clojure ecosystem provides at least two libraries for handling
argument parsing:

- [[https://github.com/clojure/tools.cli][clojure.tools.cli]]
- [[https://github.com/nubank/docopt.clj][nubank/docopt.clj]]

Babashka provides the [[https://github.com/babashka/cli][babashka.cli library]] for both parsing options and
dispatches subcommands. We'll briefly look at clojure.tools.cli, then focus on
babashka.cli.

** clojure.tools.cli

clojure.tools.cli lets you create a kind of schema for command line options. For
each option, you can define:

- its short and long flags (e.g. ~-e~ and ~--entry~)
- whether the argument is required
- validation functions
- help text
- a default value
- a parsing function

Here's what that would look like:

#+begin_src clojure
(require '[clojure.tools.cli :as cli])
(def cli-opts
  [["-e" "--entry ENTRY" "Text of your entry"]
   ["-t" "--timestamp"
    :parse-fn #(Integer/parseInt %)
    :validate [nat-int? "Must be 0 or greater"]]])

(cli/parse-opts ["-e" "dreamt I was a butterfly"] cli-opts)
;; =>
{:options {:entry "dreamt I was a butterfly"},
 :arguments [],
 :summary "  -e, --entry ENTRY  Text of your entry\n  -t, --timestamp",
 :errors nil}
#+end_src

The first schema, ~["-e" "--entry ENTRY" "Text of your entry"]~ gives the short
and long flags and a description that can be used to produce help text. In
~"--entry ENTRY"~, the presence of ~ENTRY~ indicates that the argument is
required. If it's not included, the ~:errors~ key will be populated with an
error message:

#+CAPTION:
#+BEGIN_SRC clojure
(cli/parse-opts ["-e"] cli-opts)
;; =>
{:options {},
 :arguments [],
 :summary "  -e, --entry ENTRY  Text of your entry\n  -t, --timestamp",
 :errors ["Missing required argument for \"-e ENTRY\""]}
#+END_SRC

See the [[https://github.com/clojure/tools.cli][clojure.tools.cli docs]] for more info!

** babashka.cli

The [[https://github.com/babashka/cli][babashka.cli docs]] do a good job of explaining how to use the library to meet
all your command line parsing needs. Rather than going over every option, I'll
just focus on what we need to build our dream journal. Here's how we parse
options:

#+BEGIN_SRC clojure
(require '[babashka.cli :as cli])
(def cli-opts
  {:entry     {:alias   :e
               :desc    "Your dreams."
               :require true}
   :timestamp {:alias  :t
               :desc   "A unix timestamp, when you recorded this."
               :coerce {:timestamp :long}}})

(cli/parse-opts ["-e" "The toast had eyes :("] cli-opts)
;; =>
{:entry "The toast had eyes :("}

;; leaving out a required flag throws an exception:
(cli/parse-opts [] cli-opts)
;; exception gets thrown, this gets printed:
: Required option: :entry user
#+END_SRC

So, both clojure.tools.cli and babashka.cli will parse command line arguments
into a Clojure data structure for you. They have slightly different ways of
defining schemas, but they essentially perform the same function.

What sets babashka.cli apart is that it goes beyond option parsing to also
giving you a way to dispatch subcommands, which is exactly what we want to get
~./journal add --entry "..."~ working. Here's what the final version of
~journal~ looks like:

#+BEGIN_SRC clojure
#!/usr/bin/env bb
(require '[babashka.cli :as cli])
(require '[babashka.fs :as fs])
(require '[clojure.edn :as edn])

(def ENTRIES-LOCATION "entries.edn")

(defn read-entries
  []
  (if (fs/exists? ENTRIES-LOCATION)
    (edn/read-string (slurp ENTRIES-LOCATION))
    []))

(defn add-entry
  [{:keys [opts]}]
  (let [entries (read-entries)]
    (spit ENTRIES-LOCATION
          (conj entries
                (merge {:timestamp (System/currentTimeMillis)} ;; default timestamp
                       opts)))))

(def cli-opts
  {:entry     {:alias   :e
               :desc    "Your dreams."
               :require true}
   :timestamp {:alias  :t
               :desc   "A unix timestamp, when you recorded this."
               :coerce {:timestamp :long}}})

(def table
  [{:cmds ["add"] :fn add-entry}])

(cli/dispatch table
              ,*command-line-args*
              cli-opts)
#+END_SRC

The function ~cli/dispatch~ at the bottom takes a dispatch table as its first
argument. ~cli/dispatch~ figures out which of the arguments you passed in at the
command line correspond to commands (~"add"~ in this case), and then calls the
corresponding ~:fn~ (~add-entry~ in this case).

The dispatched function receives a map as its argument, and that map contains
the ~:opts~ key. This is a map of parsed command line options, and we use it to
build our dream journal entry in the ~add-entry~ function.

And that, my friends, is how you build an interface for your script!

* COMMENT outline
** What is babashka?
*** how it's meant to be used
*** implementation
** Who should use it?
*** learning clojure
*** experienced clojure developers
*** people who work on the command line
** Why should you use it?
*** fast learning tool
*** powerful of a real programming language
*** seamless multithreading
*** self-contained environment
*** task management
** Installation
** Your first script
*** writing your first script
*** invoking it
*** output
** built-in facilities
** IO
** project organization
*** the library ecosystem
*** bb.edn
** pods
** tasks
